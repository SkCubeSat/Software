/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmCommsMasterSvc.h>
#include "tctlmCubeSenseCommon1.h"

/*******************************************************************************
 ***************************  GLOBAL MACROS   **********************************
 ******************************************************************************/

/*******************************************************************************
 **************************   GLOBAL FUNCTIONS   *******************************
 ******************************************************************************/

 /* SET functions */

ErrorCode tctlmCubeSenseCommon1_setCamSettings(TypeDef_TctlmEndpoint *endpoint, TctlmCubeSenseCommon1_CamSettings *setVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 126;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 5)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&buffer[0], &setVal->exposure, sizeof(U16));
        /*************************/
        MEMCPY(&buffer[2], &setVal->aGC, sizeof(U8));
        /*************************/
        MEMCPY(&buffer[3], &setVal->blueGain, sizeof(U8));
        /*************************/
        MEMCPY(&buffer[4], &setVal->redGain, sizeof(U8));
        /*************************/
        bufferSizeUsed = 5;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    return result;
}

ErrorCode tctlmCubeSenseCommon1_setCamAutoAdjust(TypeDef_TctlmEndpoint *endpoint, Boolean setVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 127;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 1)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0 = ((setVal & 0x01) << 0);
        MEMCPY(&buffer[0], &prepare0, sizeof(U8));
        /*************************/
        bufferSizeUsed = 1;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    return result;
}


 /* GET functions */

ErrorCode tctlmCubeSenseCommon1_getHealthTlm(TypeDef_TctlmEndpoint *endpoint, TctlmCubeSenseCommon1_HealthTlm *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 253;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 21)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 21)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuCurrent, &buffer[0], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuTemp, &buffer[2], sizeof(S16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuVoltage, &buffer[4], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->currentCam, &buffer[6], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->currentSram, &buffer[8], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->currentCamMax, &buffer[10], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->currentSramMax, &buffer[12], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare7;
        MEMCPY(&prepare7, &buffer[14], sizeof(U8));
        returnVal->overcurrentCam = (TctlmCubeSenseCommon1_OvercurrentResult)((prepare7 >> 0) & 0xFF);
        if ((U8)returnVal->overcurrentCam > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare8;
        MEMCPY(&prepare8, &buffer[15], sizeof(U8));
        returnVal->overcurrentSram = (TctlmCubeSenseCommon1_OvercurrentResult)((prepare8 >> 0) & 0xFF);
        if ((U8)returnVal->overcurrentSram > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(returnVal->watchdogCount, &buffer[16], 5);
    }
    /*************************/

    return result;
}

ErrorCode tctlmCubeSenseCommon1_getConfig(TypeDef_TctlmEndpoint *endpoint, TctlmCubeSenseCommon1_Config *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 254;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 7)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 7)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->camThreshold, &buffer[0], sizeof(U8));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare1;
        MEMCPY(&prepare1, &buffer[1], sizeof(U8));
        returnVal->camAutoAdjust = (Boolean)((prepare1 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->camExposure, &buffer[2], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->camAgc, &buffer[4], sizeof(U8));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->camBlueGain, &buffer[5], sizeof(U8));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->camRedGain, &buffer[6], sizeof(U8));
    }
    /*************************/

    return result;
}

