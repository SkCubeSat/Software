/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmCommsMasterSvc.h>
#include "tctlmCubeMagControlProgramCompact1.h"

/*******************************************************************************
 ***************************  GLOBAL MACROS   **********************************
 ******************************************************************************/

/*******************************************************************************
 **************************   GLOBAL FUNCTIONS   *******************************
 ******************************************************************************/

 /* SET functions */


 /* GET functions */

ErrorCode tctlmCubeMagControlProgramCompact1_getHealthTlm(TypeDef_TctlmEndpoint *endpoint, TctlmCubeMagControlProgramCompact1_HealthTlm *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 254;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 15)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 15)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuCurrent, &buffer[0], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuTemp, &buffer[2], sizeof(S16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U16 prepare2;
        MEMCPY(&prepare2, &buffer[4], sizeof(U16));
        if (prepare2 > 5000)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
        returnVal->mcuVoltage = prepare2;
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        F32 prepare3;
        MEMCPY(&prepare3, &buffer[6], sizeof(F32));
        if ((prepare3 < -75) || (prepare3 > 150))
        {
            result = CUBEOBC_ERROR_PARAM;
        }
        returnVal->magTemp = prepare3;
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(returnVal->watchdogCount, &buffer[10], 5);
    }
    /*************************/

    return result;
}

