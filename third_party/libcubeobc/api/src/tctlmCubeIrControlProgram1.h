/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#ifndef TCTLM_CUBE_IR_CONTROL_PROGRAM_1__H
#define TCTLM_CUBE_IR_CONTROL_PROGRAM_1__H

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmDef.h>
#include "tctlmCommonFrameworkEnums.h"
#include "tctlmCommonFramework1.h"
#include "tctlmCommonTransfer1.h"

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
 *******************************   DEFINES   ***********************************
 ******************************************************************************/

/*******************************************************************************
 *******************************   TYPEDEFS  ***********************************
 ******************************************************************************/

/**
 * @brief Enumeration for TctlmCubeIrControlProgram1_DetectResult
*/
typedef enum TctlmCubeIrControlProgram1_DetectResultEnum {
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__DET_STARTUP = 0,      /**< Initialised */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__DET_PENDING = 1,      /**< Detection in progress */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__NO_HORIZON = 2,       /**< No horizon detected in field of view */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__TOO_FEW_EDGES = 3,    /**< Not enough edge points detected */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__BAD_FIT = 4,          /**< Failed to fit shape on horizon */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__SUCCESS = 5,          /**< Horizon detected */
} TctlmCubeIrControlProgram1_DetectResult;

/**
 * @brief Enumeration for TctlmCubeIrControlProgram1_CaptureResult
*/
typedef enum TctlmCubeIrControlProgram1_CaptureResultEnum {
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__CAP_STARTUP = 0,    /**< Initialised */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__CAP_PENDING = 1,    /**< Capture in progress */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__CAP_SUCCESS = 2,    /**< Successful capture */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__CAP_TIMEOUT = 3,    /**< Timeout waiting for capture to complete */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__CAP_ERROR = 4,      /**< Camera driver error */
} TctlmCubeIrControlProgram1_CaptureResult;

/**
 * @brief Enumeration for TctlmCubeIrControlProgram1_DirSelection
*/
typedef enum TctlmCubeIrControlProgram1_DirSelectionEnum {
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__DOWNLOAD = 0,    /**< Download from node */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__UPLOAD = 1,      /**< Upload to node */
} TctlmCubeIrControlProgram1_DirSelection;

/**
 * @brief Enumeration for TctlmCubeIrControlProgram1_DataSelection
*/
typedef enum TctlmCubeIrControlProgram1_DataSelectionEnum {
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__IMAGE_CALIBRATED = 0,      /**< Calibrated image */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__IMAGE_FILTERED = 1,        /**< Filtered (smoothed) image */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__HORIZON_EDGES = 2,         /**< Horizon Edges */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__EEPROMDATA = 3,            /**< EEPROM data */
    TCTLM_CUBE_IR_CONTROL_PROGRAM_1__IMAGE_ELEC_OFFSETS = 4,    /**< Raw image electrical offsets */
} TctlmCubeIrControlProgram1_DataSelection;

/**
 * @brief Sensor Measurement message structure
 * @details Sensor measurement result
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_MeasurementStruct {
    F64 elevation;                                              /**< Measured elevation angle  (measurment unit is [deg]. valid range is between -9000 deg and 9000 deg) */
    F64 rotation;                                               /**< Measured rotation angle  (measurment unit is [deg]. valid range is between -18000 deg and 18000 deg) */
    TctlmCubeIrControlProgram1_CaptureResult captureResult;     /**< Result of image capture operation  */
    TctlmCubeIrControlProgram1_DetectResult detectionResult;    /**< Result of horizon detection operation  */
} TctlmCubeIrControlProgram1_Measurement;

/**
 * @brief Sensor Measurement Trigger message structure
 * @details Sensor measurement result (and initiate next measurement)
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_MeasurementAndTriggerStruct {
    F64 elevation;                                              /**< Measured elevation angle  (measurment unit is [deg]. valid range is between -9000 deg and 9000 deg) */
    F64 rotation;                                               /**< Measured rotation angle  (measurment unit is [deg]. valid range is between -18000 deg and 18000 deg) */
    TctlmCubeIrControlProgram1_CaptureResult captureResult;     /**< Result of image capture operation  */
    TctlmCubeIrControlProgram1_DetectResult detectionResult;    /**< Result of horizon detection operation  */
} TctlmCubeIrControlProgram1_MeasurementAndTrigger;

/**
 * @brief Measurement Meta-data message structure
 * @details Sensor measurement meta-data
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_MeasurementMetadataStruct {
    U16 minPix;           /**< Minimum pixel value  */
    U16 maxPix;           /**< Maximum pixel value  */
    U16 avgPix;           /**< Average pixel value  */
    U16 numEdgesRaw;      /**< Number of detected edges  */
    U16 numEdgesCalib;    /**< Number of detected good edges after outlier rejection  */
    U16 numWarmPix;       /**< Number of pixels found within the circular mask that is considered as earth/sun  */
    U16 numColdPix;       /**< Number of pixels found within the circular mask that is considered as space  */
    F32 circleCenterX;    /**< Centre of fitted circle X-coordinate  (measurment unit is [pixels]. valid range is between -100000 pixels and 100000 pixels) */
    F32 circleCenterY;    /**< Centre of fitted circle Y-coordinate  (measurment unit is [pixels]. valid range is between -100000 pixels and 100000 pixels) */
    F32 circleRadius;     /**< Radius of fitted circle  (measurment unit is [pixels]. valid range is between 0 pixels and 100000 pixels) */
} TctlmCubeIrControlProgram1_MeasurementMetadata;

/**
 * @brief Setup Image Transfer message structure
 * @details Setup image transfer details
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_ImageTransferSetupStruct {
    TctlmCubeIrControlProgram1_DataSelection dataSelect;    /**< Dsta selection  */
    TctlmCubeIrControlProgram1_DirSelection direction;      /**< Download or upload image  */
} TctlmCubeIrControlProgram1_ImageTransferSetup;

/**
 * @brief Health Telemetry message structure
 * @details Housekeeping telemetry and error flags
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_HealthTlmStruct {
    S16 mcuTemp;            /**< MCU Temperature  (measurment unit is [°C]. valid range is between -100 °C and 200 °C) */
    U16 detectorTemp;       /**< Detector ambient temperature  (measurment unit is [dK]. valid range is between 0 dK and 5000 dK) */
    U16 mcuCurrent;         /**< MCU current  (measurment unit is [mA]. valid range is between 0 mA and 1000 mA) */
    U16 detectorCurrent;    /**< Detector current  (measurment unit is [mA]. valid range is between 0 mA and 1000 mA) */
    U16 mcuVoltage;         /**< MCU supply voltage  (measurment unit is [mV]. valid range is between 0 mV and 5000 mV) */
    U8 watchdogCount[5];    /**< Bitmask representing virtual watchdog region warning counters.  */
} TctlmCubeIrControlProgram1_HealthTlm;

/**
 * @brief Configuration message structure
 * @details Detector and sensor configuration settings
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_ConfigurationStruct {
    Boolean calibrateImageFull;         /**< Set to true to perform full Vdd and temperature compensation. Otherwise only electrical offsets  */
    Boolean useCalibrationRig;          /**< Set to true to if doing calibration/verification on the rig  */
    U8 circularMaskRadius;              /**< Circular mask within which to attempt detection  */
    U16 minimumTempDiff;                /**< Minimum temperature difference in dK to be considered a horizon  */
    F32 expectedEarthRadius;            /**< The expected radius of earth at the current altitude  (valid range is between 0  and 300 ) */
    F32 allowedRadiusDeviation;         /**< The maximum allowable deviation from the expected Earth radius, used to reject invalid measurements.  (valid range is between 0  and 50 ) */
    U16 maxSpaceTemp;                   /**< Temperature used to calculate histogram scan boundaries for determining temperature thresholds  */
    U16 maxEarthTempOffset;             /**< Offset from 'maxSpaceTemp' to determine 'maxEarthTemp'  */
    U16 minSpaceTempOffset;             /**< Offset from 'maxSpaceTemp' to determine 'minSpaceTemp'  */
    U16 maxEarthTempThresholdOffset;    /**< Offset from detected average Earth temp to determine 'maxEarthTempThreshold'  */
    U8 horizonCrossOverOffset;          /**< Offset from detected Space temperature to determine 'minEarthTempThreshold'  */
    S32 gradientOutlierThreshold;       /**< Used to filter out sun pixels and lens flares  */
    U16 validBinPeak;                   /**< The threshold for a valid bin peak  */
    U16 binWidth;                       /**< Used to calculate the number of bins in the histogram  */
    U16 minimumGradient;                /**< Minimum gradient to be considered a horizon  */
    U8 minimumEdgePointsRequired;       /**< The minimum amount of edge points required to do a polynomial fitting  */
    U16 circRadiusMin;                  /**< Minimum allowable radius for fitted circle.  */
    U16 circRadiusMax;                  /**< Maximum allowable radius for fitted circle.  */
    F32 horElevBias;                    /**< A constant bias to add to the measured elevation [Radians]  */
    U16 outlierRejMaxSeg;               /**< Maximum allowable segment to delete in outlier rejection (zero to disable).  */
    U8 outlierRejTol;                   /**< Maximum allowable distance between points for outlier rejection   */
    F32 boresightX;                     /**< Lens distortion model bore-sight X coordinate  (valid range is between 0  and 80 ) */
    F32 boresightY;                     /**< Lens distortion model bore-sight Y coordinate  (valid range is between 0  and 64 ) */
    F32 focalLength;                    /**< Lens distortion model focal length  (valid range is between 0  and 100 ) */
    F32 distK1;                         /**< Lens distortion model coefficient K1  (valid range is between -100  and 100 ) */
    F32 distK2;                         /**< Lens distortion model coefficient K2  (valid range is between -100  and 100 ) */
    F32 distK3;                         /**< Lens distortion model coefficient K3  (valid range is between -100  and 100 ) */
    F32 distK4;                         /**< Lens distortion model coefficient K4  (valid range is between -100  and 100 ) */
    F32 distK5;                         /**< Lens distortion model coefficient K5  (valid range is between -100  and 100 ) */
    F32 distK6;                         /**< Lens distortion model coefficient K6  (valid range is between -100  and 100 ) */
    F32 distP1;                         /**< Lens distortion model coefficient P1  (valid range is between -100  and 100 ) */
    F32 distP2;                         /**< Lens distortion model coefficient P2  (valid range is between -100  and 100 ) */
} TctlmCubeIrControlProgram1_Configuration;

/**
 * @brief DeadPixels message structure
 * @details Pixels that are dead in the camera
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_DeadPixelsStruct {
    U8 deadPixelIndex;    /**< Index of dead pixel  */
    U8 pixelX;            /**< X Coordinate of dead pixel  */
    U8 pixelY;            /**< Y Coordinate of dead pixel  */
    U8 pixelMask;         /**< Mask of dead pixel  */
} TctlmCubeIrControlProgram1_DeadPixels;

/**
 * @brief RequestedDeadPixel message structure
 * @details Pixels that are dead in the camera
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_RequestedDeadPixelStruct {
    U8 deadPixelIndex;    /**< Index of dead pixel  */
    U8 pixelX;            /**< X Coordinate of dead pixel  */
    U8 pixelY;            /**< Y Coordinate of dead pixel  */
    U8 pixelMask;         /**< Mask of dead pixel  */
} TctlmCubeIrControlProgram1_RequestedDeadPixel;

/**
 * @brief Profile Timing message structure
 * @details Measured exection time for capture and detect operations
 */
typedef struct TCTLM_PACKED TctlmCubeIrControlProgram1_ProfileTimingStruct {
    U16 timeCapture;      /**< Time to complete capture  (measurment unit is [ms]. valid range is between 0 ms and 2000 ms) */
    U16 timeCalibrate;    /**< Time to calibrate image  (measurment unit is [ms]. valid range is between 0 ms and 2000 ms) */
    U16 timeDetect;       /**< Time to detect horizon  (measurment unit is [ms]. valid range is between 0 ms and 2000 ms) */
} TctlmCubeIrControlProgram1_ProfileTiming;


/*******************************************************************************
 *****************************   PROTOTYPES   **********************************
 ******************************************************************************/

 /* SET function prototypes */

/**
 * @brief ID 62, RequestDeadPixel
 * @details Pixels that are dead in the camera
 *
 * @param[in] endpoint Node endpoint location
 * @param[in] setVal Value Written
 *
 * @return ErrorCode ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_setRequestDeadPixel(TypeDef_TctlmEndpoint *endpoint, U8 setVal);

/**
 * @brief ID 63, Setup Image Transfer
 * @details Setup image transfer details
 *
 * @param[in] endpoint Node endpoint location
 * @param[in] setVal Value Written
 *
 * @return ErrorCode ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_setImageTransferSetup(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_ImageTransferSetup *setVal);

/**
 * @brief ID 64, Configuration
 * @details Detector and sensor configuration settings
 *
 * @param[in] endpoint Node endpoint location
 * @param[in] setVal Value Written
 *
 * @return ErrorCode ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_setConfiguration(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_Configuration *setVal);

/**
 * @brief ID 65, DeadPixels
 * @details Pixels that are dead in the camera
 *
 * @param[in] endpoint Node endpoint location
 * @param[in] setVal Value Written
 *
 * @return ErrorCode ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_setDeadPixels(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_DeadPixels *setVal);


 /* GET function prototypes */

/**
 * @brief ID 187, RequestedDeadPixel
 * @details Pixels that are dead in the camera
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getRequestedDeadPixel(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_RequestedDeadPixel* returnVal);

/**
 * @brief ID 190, Health Telemetry
 * @details Housekeeping telemetry and error flags
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getHealthTlm(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_HealthTlm* returnVal);

/**
 * @brief ID 192, Sensor Measurement Trigger
 * @details Sensor measurement result (and initiate next measurement)
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getMeasurementAndTrigger(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_MeasurementAndTrigger* returnVal);

/**
 * @brief ID 193, Sensor Measurement
 * @details Sensor measurement result
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getMeasurement(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_Measurement* returnVal);

/**
 * @brief ID 194, Measurement Meta-data
 * @details Sensor measurement meta-data
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getMeasurementMetadata(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_MeasurementMetadata* returnVal);

/**
 * @brief ID 195, Configuration
 * @details Detector and sensor configuration settings
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getConfiguration(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_Configuration* returnVal);

/**
 * @brief ID 197, Profile Timing
 * @details Measured exection time for capture and detect operations
 *
 * @param[in] endpoint Node endpoint location
 * @param[out] returnVal Value Returned
 *
 * @return ErrorCode TCTLM__ERROR_OK on success
 */
ErrorCode tctlmCubeIrControlProgram1_getProfileTiming(TypeDef_TctlmEndpoint *endpoint, TctlmCubeIrControlProgram1_ProfileTiming* returnVal);


#ifdef __cplusplus
}
#endif

#endif // TCTLM_CUBE_IR_CONTROL_PROGRAM_1_H
