/************************************************************************************
 * This file was auto-generated by CIDEA                           .                *
 * Please do not modify the contents of this file manually.                         *
 ***********************************************************************************/

#include <cubeObc/cubeObc_typeDef.h>
#include <cubeObc/cubeObc_errorDef.h>
#include <cubeObc/cubeObc_tctlmCommsMasterSvc.h>
#include "tctlmCubeNodeCommon1.h"

/*******************************************************************************
 ***************************  GLOBAL MACROS   **********************************
 ******************************************************************************/

/*******************************************************************************
 **************************   GLOBAL FUNCTIONS   *******************************
 ******************************************************************************/

 /* SET functions */

ErrorCode tctlmCubeNodeCommon1_setPowerSwitchState(TypeDef_TctlmEndpoint *endpoint, TctlmCubeNodeCommon1_PowerSwitchState *setVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 127;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 1)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0 = ((setVal->activeState1 & 0x01) << 0)
                    | ((setVal->activeState2 & 0x01) << 1)
                    | ((setVal->activeState3 & 0x01) << 2)
                    | ((setVal->activeState4 & 0x01) << 3);
        MEMCPY(&buffer[0], &prepare0, sizeof(U8));
        /*************************/
        bufferSizeUsed = 1;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    return result;
}


 /* GET functions */

ErrorCode tctlmCubeNodeCommon1_getPowerSwitchState(TypeDef_TctlmEndpoint *endpoint, TctlmCubeNodeCommon1_PowerSwitchState *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 253;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 1)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 1)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare0;
        MEMCPY(&prepare0, &buffer[0], sizeof(U8));
        returnVal->activeState1 = (TctlmCubeNodeCommon1_SwitchState)((prepare0 >> 0) & 0x01);
        if ((U8)returnVal->activeState1 > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare1;
        MEMCPY(&prepare1, &buffer[0], sizeof(U8));
        returnVal->activeState2 = (TctlmCubeNodeCommon1_SwitchState)((prepare1 >> 1) & 0x01);
        if ((U8)returnVal->activeState2 > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare2;
        MEMCPY(&prepare2, &buffer[0], sizeof(U8));
        returnVal->activeState3 = (TctlmCubeNodeCommon1_SwitchState)((prepare2 >> 2) & 0x01);
        if ((U8)returnVal->activeState3 > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare3;
        MEMCPY(&prepare3, &buffer[0], sizeof(U8));
        returnVal->activeState4 = (TctlmCubeNodeCommon1_SwitchState)((prepare3 >> 3) & 0x01);
        if ((U8)returnVal->activeState4 > 1)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
    }
    /*************************/

    return result;
}

ErrorCode tctlmCubeNodeCommon1_getHealthTlm(TypeDef_TctlmEndpoint *endpoint, TctlmCubeNodeCommon1_HealthTlm *returnVal)
{
    ErrorCode result = CUBEOBC_ERROR_OK;
    TctlmCommsMasterSvc_Endpoint target;
    U8 *buffer;
    U32 bufferSize;
    U32 bufferSizeUsed;

    ZERO_VAR(target);

    target.id = 254;
    MEMCPY((U8 *)&target.endpoint, (U8 *)endpoint, sizeof(TypeDef_TctlmEndpoint));

    buffer = cubeObc_tctlmCommsMasterSvc_buffer(&target);
    bufferSize = cubeObc_tctlmCommsMasterSvc_bufferSize(&target);

    if (bufferSize < 22)
    {
        result = CUBEOBC_ERROR_SIZEL;
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        bufferSizeUsed = 0;
        result = cubeObc_tctlmCommsMasterSvc_sendReceive(&target, &bufferSizeUsed);
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        if (bufferSizeUsed != 22)
        {
            result = CUBEOBC_ERROR_TLM_SIZE;
        }
    }

    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuCurrent, &buffer[0], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->mcuTemp, &buffer[2], sizeof(S16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U16 prepare2;
        MEMCPY(&prepare2, &buffer[4], sizeof(U16));
        if (prepare2 > 5000)
        {
            result = CUBEOBC_ERROR_PARAM;
        }
        returnVal->mcuVoltage = prepare2;
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->vBattCurrent1, &buffer[6], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->vBattCurrent2, &buffer[8], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->vBattCurrent3, &buffer[10], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->vBattCurrent4, &buffer[12], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare7;
        MEMCPY(&prepare7, &buffer[14], sizeof(U8));
        returnVal->vBattOvercurrent1 = (Boolean)((prepare7 >> 0) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare8;
        MEMCPY(&prepare8, &buffer[14], sizeof(U8));
        returnVal->vBattOvercurrent2 = (Boolean)((prepare8 >> 1) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare9;
        MEMCPY(&prepare9, &buffer[14], sizeof(U8));
        returnVal->vBattOvercurrent3 = (Boolean)((prepare9 >> 2) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare10;
        MEMCPY(&prepare10, &buffer[14], sizeof(U8));
        returnVal->vBattOvercurrent4 = (Boolean)((prepare10 >> 3) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare11;
        MEMCPY(&prepare11, &buffer[14], sizeof(U8));
        returnVal->powerGood = (Boolean)((prepare11 >> 4) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        U8 prepare13;
        MEMCPY(&prepare13, &buffer[14], sizeof(U8));
        returnVal->pmuCurrentValid = (Boolean)((prepare13 >> 7) & 0x01);
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(&returnVal->pmuCurrent, &buffer[15], sizeof(U16));
    }
    /*************************/
    if (result == CUBEOBC_ERROR_OK)
    {
        MEMCPY(returnVal->watchdogCount, &buffer[17], 5);
    }
    /*************************/

    return result;
}

